---
title: 'GSAP Button'
description: 'Why you should have more than one interest'
pubDate: 'Dec 9 2023'
tags:
  - creative
  - r&d
source:
  url: https://github.com/blackmann/blackmann.github.io/
  title: Source code here
  subtitle: You can find implementation for this reasearch here
  thumbnail: thumbnail
---

import BorderFigure from '../../components/GSAPButtonPostBorderFigure.astro'

import HoverCircleFigure from '../../components/GSAPButtonHoverCircleFigure.astro'

import Specimen from '../../components/gsap-button-diff/specimen.astro'

import CreateBackground from '../../components/gsap-button-diff/background.astro'

import AddHoverCircle from '../../components/gsap-button-diff/hover-circle-add.astro'

This weekend, I wanted to pick up something new to learn. I've had [_GSAP_](https://gsap.com) on my list for a long time; so that was it!

I spent a few minutes reading the [Learning](https://gsap.com/resources) page — **Your first animation** through to **JS Frameworks**. I only did some reading/skimming as I only was interested in what it offers at a high level.

I do have some OK understanding of making animations; like what keyframes, timeline, eases, etc. mean. So I'm sure I'll be able to get more detail on those by searching on their website/docs.

But I stumbled on a cool effect when hovering [CTA](<https://en.wikipedia.org/wiki/Call_to_action_(marketing)>) buttons like Create Account, Login, etc. on their site.

- [ ] Insert finished work [button] here

In this post, I'll like to share my thought process on achieving the same result. Yes, using GSAP!

## Composition

Lets break the button apart so we can get some clues on how to reason about the implementations

### Borders

The borders of the buttons are solid, thick and rounded. Now, when the [hover circle](#hover-circle) enters the button, the intersection forms a solid fill. In the figure below, you can see how this intersection happens — this is for demonstration purposes. This means, in our implementation, we'll have to clip/mask the circle to only show the intersection.

<BorderFigure />

Thoughts:

- If the border acts as a mask over the hover circle, then the border is not a regular DOM [`border`](https://developer.mozilla.org/en-US/docs/Web/CSS/border) style.

- Or it is a DOM border style and uses CSS [clipping mask](https://css-tricks.com/clipping-masking-css/) with an SVG path.

> Feel free to share other ways it could be in the comments below. We're all learning!

In either case, we need an SVG path to define our button's borders. I mention SVG because I know SVGs have [`<mask />`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/mask) element through passive reading in the past.

But another thing to consider is that, the buttons can have variable width. (Height maybe¿). This will mean the SVG path should be generated dynamically and probably absolutely positioned. Yes, with JS.

Learn about writing SVGs from here: https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Introduction

### Hover circle

As the mouse pointer enters the button, a circle grows to fill the button almost fully. The circle grows from where the mouse entered. When the mouse leaves the button, the circle shrinks — also in the direction when the mouse exits the button.

One interesting feature is that, the hover circle expands to fill the button entirely as the mouse reaches the center. At first, I thought the circle should fill the button gradually as the mouse reaches the center. Hover your mouse on the button below from the edges to see what I mean.

<HoverCircleFigure />

You'll notice that, if the circle went gradually, it'll cause contrasting issues with the text. For accessibility reasons, it makes sense the circle behaves as done on the GSAP website, ie, _Almost fully_.

One more thing: the hover circle doesn't grow until it crosses a padding threshold on the horizontal axis.

While not captured in the figure above, the anchor for the circle is locked from where the mouse entered

### Text

The text changes color when hovered. To white — based on the theme/brand of GSAP. This is contrasted by the [hover circle](#hover-circle) which is black.

## Specifications

From the composition developed above, here are some specifications I've come up for the button — the GSAP button.

1. The effect should work on buttons or links (`<a />`)
1. The hover circle uses the `almost-fully` strategy.
1. The padding threshold determines how far the hover-circle expands when the mouse enters the element.
1. The hover circle fills the rest of the space in proportion to how close the mouse pointer is to the center, horizontally.
1. The text changes color when hovered.

## Generalizing

I like to generalize my solutions so I can reuse them wherever. Some thoughts about generalization goes like:

1. The effect should be able to work on any element; regardless of orientation. Square, landscape and portrait elements should work.
1. Since the effect should work on any element of any shape/size, responsiveness should handled. Maybe for performance reasons, when the window resizes, we only reapply the effect if the size of element changes.
1. It should work with any UI framework like React, and also work with Vanilla.

## Approach

We're going to use the following as the specimen for our project:

<Specimen />

### 1. The API

We should be able to do something like any of the following to apply the effect. I (personally) always like to start from the API, then drill down to details.

```js
// pass queryselector
// this will select all elements witht his class (gsap-button)
applyGsapHoverEffect('.gsap-button')

// pass element
// this will work when used with frameworks like React.
// Then, we'll have to do something like `applyGsapHoverEffect(ref.current)`
const button = document.querySelector('#login-button')
applyGsapHoverEffect(button)

// pass array of elements
const buttons = document.querySelectorAll('.gsap-button')
applyGsapHoverEffect(buttons)
```

In Typescript, we'll have our API signature like below

```typescript
function applyGsapHoverEffect(el: string | HTMLElement | HTMLElement[]) {
  // we wouldn't want to do lots if/else depending of the type of `el`
  // so we can normalize `el` to be an array

  const elements = [
    typeof el === 'string' ? Array.from(document.querySelectorAll(el)) : el,
  ].flat()
}
```

If you're confused about `.flat()`: since `el` can be a single `HTMLElement` or an array, we could end up with nested array. `.flat()` un-nests it one level — which is enough.

> Take off `.flat()` and do a `console.log` to see what it looks like when you pass a query selector.

### 2. The background

We will have to insert an SVG element below the text. To do that, we have to ensure the element has `relative` positioning so that we can have our SVG `absolute`ly positioned inside it.

The code below demonstrates how I accomplished this. Ignore the light shade of background — it won't make it to the final work.

<CreateBackground />

```typescript
for (const el of elements) {
  el.style.position = 'relative'

  const bg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
  bg.style.cssText = `
    position: absolute;
    background: #e9e9e9;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    z-index: -1;
    border-radius: 1.8rem;
`

  el.insertAdjacentElement('afterbegin', bg)
}
```

### 3. Clip + Circle

By design, the SVGs shape clips its contents — providence! This means we can just add our hover [`<circle />`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle) without needing a [`<clipPath />`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/clipPath).


```typescript
// ...

// add these attributes to the bg (SVG) so that we can do
// relative positioning using percentages

bg.setAttribute('width', `${el.clientWidth}`)
bg.setAttribute('height', `${el.clientHeight}`)

const circle = document.createElementNS(
  'http://www.w3.org/2000/svg',
  'circle'
)

circle.setAttribute('cx', '100%')
circle.setAttribute('cy', '100%')
circle.setAttribute('r', '125%')
circle.setAttribute('fill', '#333')

bg.appendChild(circle)

el.insertAdjacentElement('afterbegin', bg)

```

This is what our specimen looks like with this addition:

<AddHoverCircle />
